// Generated by Sichem at 31.03.2017 12:51:03

using System;
using System.Runtime.InteropServices;
using Sichem;

namespace StbSharp
{
	unsafe partial class Stb
	{
		[StructLayout(LayoutKind.Sequential)]
		public unsafe struct stbir__contributors
		{
			public int n0;
			public int n1;
		}

		public const int STBIR_EDGE_CLAMP = 1;
		public const int STBIR_EDGE_REFLECT = 2;
		public const int STBIR_EDGE_WRAP = 3;
		public const int STBIR_EDGE_ZERO = 4;
		public const int STBIR_FILTER_DEFAULT = 0;
		public const int STBIR_FILTER_BOX = 1;
		public const int STBIR_FILTER_TRIANGLE = 2;
		public const int STBIR_FILTER_CUBICBSPLINE = 3;
		public const int STBIR_FILTER_CATMULLROM = 4;
		public const int STBIR_FILTER_MITCHELL = 5;
		public const int STBIR_COLORSPACE_LINEAR = 0;
		public const int STBIR_COLORSPACE_SRGB = 1;
		public const int STBIR_MAX_COLORSPACES = 2;
		public const int STBIR_TYPE_UINT8 = 0;
		public const int STBIR_TYPE_UINT16 = 1;
		public const int STBIR_TYPE_UINT32 = 2;
		public const int STBIR_TYPE_FLOAT = 3;
		public const int STBIR_MAX_TYPES = 4;

		public static PinnedArray<byte> stbir__type_size =
			new PinnedArray<byte>(new byte[] {(byte) (1), (byte) (2), (byte) (4), (byte) (4)});

		public static PinnedArray<float> stbir__srgb_uchar_to_linear_float =
			new PinnedArray<float>(new float[]
			{
				(float) (0.000000f), (float) (0.000304f), (float) (0.000607f), (float) (0.000911f), (float) (0.001214f),
				(float) (0.001518f), (float) (0.001821f), (float) (0.002125f), (float) (0.002428f), (float) (0.002732f),
				(float) (0.003035f), (float) (0.003347f), (float) (0.003677f), (float) (0.004025f), (float) (0.004391f),
				(float) (0.004777f), (float) (0.005182f), (float) (0.005605f), (float) (0.006049f), (float) (0.006512f),
				(float) (0.006995f), (float) (0.007499f), (float) (0.008023f), (float) (0.008568f), (float) (0.009134f),
				(float) (0.009721f), (float) (0.010330f), (float) (0.010960f), (float) (0.011612f), (float) (0.012286f),
				(float) (0.012983f), (float) (0.013702f), (float) (0.014444f), (float) (0.015209f), (float) (0.015996f),
				(float) (0.016807f), (float) (0.017642f), (float) (0.018500f), (float) (0.019382f), (float) (0.020289f),
				(float) (0.021219f), (float) (0.022174f), (float) (0.023153f), (float) (0.024158f), (float) (0.025187f),
				(float) (0.026241f), (float) (0.027321f), (float) (0.028426f), (float) (0.029557f), (float) (0.030713f),
				(float) (0.031896f), (float) (0.033105f), (float) (0.034340f), (float) (0.035601f), (float) (0.036889f),
				(float) (0.038204f), (float) (0.039546f), (float) (0.040915f), (float) (0.042311f), (float) (0.043735f),
				(float) (0.045186f), (float) (0.046665f), (float) (0.048172f), (float) (0.049707f), (float) (0.051269f),
				(float) (0.052861f), (float) (0.054480f), (float) (0.056128f), (float) (0.057805f), (float) (0.059511f),
				(float) (0.061246f), (float) (0.063010f), (float) (0.064803f), (float) (0.066626f), (float) (0.068478f),
				(float) (0.070360f), (float) (0.072272f), (float) (0.074214f), (float) (0.076185f), (float) (0.078187f),
				(float) (0.080220f), (float) (0.082283f), (float) (0.084376f), (float) (0.086500f), (float) (0.088656f),
				(float) (0.090842f), (float) (0.093059f), (float) (0.095307f), (float) (0.097587f), (float) (0.099899f),
				(float) (0.102242f), (float) (0.104616f), (float) (0.107023f), (float) (0.109462f), (float) (0.111932f),
				(float) (0.114435f), (float) (0.116971f), (float) (0.119538f), (float) (0.122139f), (float) (0.124772f),
				(float) (0.127438f), (float) (0.130136f), (float) (0.132868f), (float) (0.135633f), (float) (0.138432f),
				(float) (0.141263f), (float) (0.144128f), (float) (0.147027f), (float) (0.149960f), (float) (0.152926f),
				(float) (0.155926f), (float) (0.158961f), (float) (0.162029f), (float) (0.165132f), (float) (0.168269f),
				(float) (0.171441f), (float) (0.174647f), (float) (0.177888f), (float) (0.181164f), (float) (0.184475f),
				(float) (0.187821f), (float) (0.191202f), (float) (0.194618f), (float) (0.198069f), (float) (0.201556f),
				(float) (0.205079f), (float) (0.208637f), (float) (0.212231f), (float) (0.215861f), (float) (0.219526f),
				(float) (0.223228f), (float) (0.226966f), (float) (0.230740f), (float) (0.234551f), (float) (0.238398f),
				(float) (0.242281f), (float) (0.246201f), (float) (0.250158f), (float) (0.254152f), (float) (0.258183f),
				(float) (0.262251f), (float) (0.266356f), (float) (0.270498f), (float) (0.274677f), (float) (0.278894f),
				(float) (0.283149f), (float) (0.287441f), (float) (0.291771f), (float) (0.296138f), (float) (0.300544f),
				(float) (0.304987f), (float) (0.309469f), (float) (0.313989f), (float) (0.318547f), (float) (0.323143f),
				(float) (0.327778f), (float) (0.332452f), (float) (0.337164f), (float) (0.341914f), (float) (0.346704f),
				(float) (0.351533f), (float) (0.356400f), (float) (0.361307f), (float) (0.366253f), (float) (0.371238f),
				(float) (0.376262f), (float) (0.381326f), (float) (0.386430f), (float) (0.391573f), (float) (0.396755f),
				(float) (0.401978f), (float) (0.407240f), (float) (0.412543f), (float) (0.417885f), (float) (0.423268f),
				(float) (0.428691f), (float) (0.434154f), (float) (0.439657f), (float) (0.445201f), (float) (0.450786f),
				(float) (0.456411f), (float) (0.462077f), (float) (0.467784f), (float) (0.473532f), (float) (0.479320f),
				(float) (0.485150f), (float) (0.491021f), (float) (0.496933f), (float) (0.502887f), (float) (0.508881f),
				(float) (0.514918f), (float) (0.520996f), (float) (0.527115f), (float) (0.533276f), (float) (0.539480f),
				(float) (0.545725f), (float) (0.552011f), (float) (0.558340f), (float) (0.564712f), (float) (0.571125f),
				(float) (0.577581f), (float) (0.584078f), (float) (0.590619f), (float) (0.597202f), (float) (0.603827f),
				(float) (0.610496f), (float) (0.617207f), (float) (0.623960f), (float) (0.630757f), (float) (0.637597f),
				(float) (0.644480f), (float) (0.651406f), (float) (0.658375f), (float) (0.665387f), (float) (0.672443f),
				(float) (0.679543f), (float) (0.686685f), (float) (0.693872f), (float) (0.701102f), (float) (0.708376f),
				(float) (0.715694f), (float) (0.723055f), (float) (0.730461f), (float) (0.737911f), (float) (0.745404f),
				(float) (0.752942f), (float) (0.760525f), (float) (0.768151f), (float) (0.775822f), (float) (0.783538f),
				(float) (0.791298f), (float) (0.799103f), (float) (0.806952f), (float) (0.814847f), (float) (0.822786f),
				(float) (0.830770f), (float) (0.838799f), (float) (0.846873f), (float) (0.854993f), (float) (0.863157f),
				(float) (0.871367f), (float) (0.879622f), (float) (0.887923f), (float) (0.896269f), (float) (0.904661f),
				(float) (0.913099f), (float) (0.921582f), (float) (0.930111f), (float) (0.938686f), (float) (0.947307f),
				(float) (0.955974f), (float) (0.964686f), (float) (0.973445f), (float) (0.982251f), (float) (0.991102f),
				(float) (1.0f)
			});

		public static PinnedArray<uint> fp32_to_srgb8_tab4 =
			new PinnedArray<uint>(new uint[]
			{
				(uint) (0x0073000d), (uint) (0x007a000d), (uint) (0x0080000d), (uint) (0x0087000d), (uint) (0x008d000d),
				(uint) (0x0094000d), (uint) (0x009a000d), (uint) (0x00a1000d), (uint) (0x00a7001a), (uint) (0x00b4001a),
				(uint) (0x00c1001a), (uint) (0x00ce001a), (uint) (0x00da001a), (uint) (0x00e7001a), (uint) (0x00f4001a),
				(uint) (0x0101001a), (uint) (0x010e0033), (uint) (0x01280033), (uint) (0x01410033), (uint) (0x015b0033),
				(uint) (0x01750033), (uint) (0x018f0033), (uint) (0x01a80033), (uint) (0x01c20033), (uint) (0x01dc0067),
				(uint) (0x020f0067), (uint) (0x02430067), (uint) (0x02760067), (uint) (0x02aa0067), (uint) (0x02dd0067),
				(uint) (0x03110067), (uint) (0x03440067), (uint) (0x037800ce), (uint) (0x03df00ce), (uint) (0x044600ce),
				(uint) (0x04ad00ce), (uint) (0x051400ce), (uint) (0x057b00c5), (uint) (0x05dd00bc), (uint) (0x063b00b5),
				(uint) (0x06970158), (uint) (0x07420142), (uint) (0x07e30130), (uint) (0x087b0120), (uint) (0x090b0112),
				(uint) (0x09940106), (uint) (0x0a1700fc), (uint) (0x0a9500f2), (uint) (0x0b0f01cb), (uint) (0x0bf401ae),
				(uint) (0x0ccb0195), (uint) (0x0d950180), (uint) (0x0e56016e), (uint) (0x0f0d015e), (uint) (0x0fbc0150),
				(uint) (0x10630143), (uint) (0x11070264), (uint) (0x1238023e), (uint) (0x1357021d), (uint) (0x14660201),
				(uint) (0x156601e9), (uint) (0x165a01d3), (uint) (0x174401c0), (uint) (0x182401af), (uint) (0x18fe0331),
				(uint) (0x1a9602fe), (uint) (0x1c1502d2), (uint) (0x1d7e02ad), (uint) (0x1ed4028d), (uint) (0x201a0270),
				(uint) (0x21520256), (uint) (0x227d0240), (uint) (0x239f0443), (uint) (0x25c003fe), (uint) (0x27bf03c4),
				(uint) (0x29a10392), (uint) (0x2b6a0367), (uint) (0x2d1d0341), (uint) (0x2ebe031f), (uint) (0x304d0300),
				(uint) (0x31d105b0), (uint) (0x34a80555), (uint) (0x37520507), (uint) (0x39d504c5), (uint) (0x3c37048b),
				(uint) (0x3e7c0458), (uint) (0x40a8042a), (uint) (0x42bd0401), (uint) (0x44c20798), (uint) (0x488e071e),
				(uint) (0x4c1c06b6), (uint) (0x4f76065d), (uint) (0x52a50610), (uint) (0x55ac05cc), (uint) (0x5892058f),
				(uint) (0x5b590559), (uint) (0x5e0c0a23), (uint) (0x631c0980), (uint) (0x67db08f6), (uint) (0x6c55087f),
				(uint) (0x70940818), (uint) (0x74a007bd), (uint) (0x787d076c), (uint) (0x7c330723)
			});

		public static int stbir__min(int a, int b)
		{
			return (int) ((a) < (b) ? a : b);
		}

		public static int stbir__max(int a, int b)
		{
			return (int) ((a) > (b) ? a : b);
		}

		public static float stbir__saturate(float x)
		{
			if ((x) < (0)) return (float) (0);
			if ((x) > (1)) return (float) (1);
			return (float) (x);
		}

		public static float stbir__srgb_to_linear(float f)
		{
			if (f <= 0.04045f) return (float) (f/12.92f);
			else return (float) (pow((double) ((f + 0.055f)/1.055f), (double) (2.4f)));
		}

		public static float stbir__linear_to_srgb(float f)
		{
			if (f <= 0.0031308f) return (float) (f*12.92f);
			else return (float) (1.055f*(float) (pow((double) (f), (double) (1/2.4f))) - 0.055f);
		}

		public static float stbir__filter_trapezoid(float x, float scale)
		{
			float halfscale = (float) (scale/2);
			float t = (float) (0.5f + halfscale);
			x = (float) ((float) (fabs((double) (x))));
			if ((x) >= (t)) return (float) (0);
			else
			{
				float r = (float) (0.5f - halfscale);
				if (x <= r) return (float) (1);
				else return (float) ((t - x)/scale);
			}

		}

		public static float stbir__support_trapezoid(float scale)
		{
			return (float) (0.5f + scale/2);
		}

		public static float stbir__filter_triangle(float x, float s)
		{
			x = (float) ((float) (fabs((double) (x))));
			if (x <= 1.0f) return (float) (1 - x);
			else return (float) (0);
		}

		public static float stbir__filter_cubic(float x, float s)
		{
			x = (float) ((float) (fabs((double) (x))));
			if ((x) < (1.0f)) return (float) ((4 + x*x*(3*x - 6))/6);
			else if ((x) < (2.0f)) return (float) ((8 + x*(-12 + x*(6 - x)))/6);
			return (float) (0.0f);
		}

		public static float stbir__filter_catmullrom(float x, float s)
		{
			x = (float) ((float) (fabs((double) (x))));
			if ((x) < (1.0f)) return (float) (1 - x*x*(2.5f - 1.5f*x));
			else if ((x) < (2.0f)) return (float) (2 - x*(4 + x*(0.5f*x - 2.5f)));
			return (float) (0.0f);
		}

		public static float stbir__filter_mitchell(float x, float s)
		{
			x = (float) ((float) (fabs((double) (x))));
			if ((x) < (1.0f)) return (float) ((16 + x*x*(21*x - 36))/18);
			else if ((x) < (2.0f)) return (float) ((32 + x*(-60 + x*(36 - 7*x)))/18);
			return (float) (0.0f);
		}

		public static float stbir__support_zero(float s)
		{
			return (float) (0);
		}

		public static float stbir__support_one(float s)
		{
			return (float) (1);
		}

		public static float stbir__support_two(float s)
		{
			return (float) (2);
		}

		public static int stbir__use_upsampling(float ratio)
		{
			return (int) ((ratio) > (1) ? 1 : 0);
		}

		public static int stbir__use_width_upsampling(stbir__info stbir_info)
		{
			return (int) (stbir__use_upsampling((float) (stbir_info.horizontal_scale)));
		}

		public static int stbir__use_height_upsampling(stbir__info stbir_info)
		{
			return (int) (stbir__use_upsampling((float) (stbir_info.vertical_scale)));
		}

		public static int stbir__get_filter_pixel_width(int filter, float scale)
		{
			if ((stbir__use_upsampling((float) (scale))) != 0)
				return (int) (ceil((double) (stbir__filter_info_table[filter].support((float) (1/scale))*2)));
			else return (int) (ceil((double) (stbir__filter_info_table[filter].support((float) (scale))*2/scale)));
		}

		public static int stbir__get_filter_pixel_margin(int filter, float scale)
		{
			return (int) (stbir__get_filter_pixel_width((int) (filter), (float) (scale))/2);
		}

		public static int stbir__get_coefficient_width(int filter, float scale)
		{
			if ((stbir__use_upsampling((float) (scale))) != 0)
				return (int) (ceil((double) (stbir__filter_info_table[filter].support((float) (1/scale))*2)));
			else return (int) (ceil((double) (stbir__filter_info_table[filter].support((float) (scale))*2)));
		}

		public static int stbir__get_contributors(float scale, int filter, int input_size, int output_size)
		{
			if ((stbir__use_upsampling((float) (scale))) != 0) return (int) (output_size);
			else return (int) (input_size + stbir__get_filter_pixel_margin((int) (filter), (float) (scale))*2);
		}

		public static int stbir__get_total_horizontal_coefficients(stbir__info info)
		{
			return
				(int)
					(info.horizontal_num_contributors*
					 stbir__get_coefficient_width((int) (info.horizontal_filter), (float) (info.horizontal_scale)));
		}

		public static int stbir__get_total_vertical_coefficients(stbir__info info)
		{
			return
				(int)
					(info.vertical_num_contributors*
					 stbir__get_coefficient_width((int) (info.vertical_filter), (float) (info.vertical_scale)));
		}

		public static stbir__contributors* stbir__get_contributor(stbir__contributors* contributors, int n)
		{
			return &contributors[n];
		}

		public static float* stbir__get_coefficient(float* coefficients, int filter, float scale, int n, int c)
		{
			int width = (int) (stbir__get_coefficient_width((int) (filter), (float) (scale)));
			return &coefficients[width*n + c];
		}

		public static int stbir__edge_wrap_slow(int edge, int n, int max)
		{
			switch (edge)
			{
				case STBIR_EDGE_ZERO:
					return (int) (0);
				case STBIR_EDGE_CLAMP:
					if ((n) < (0)) return (int) (0);
					if ((n) >= (max)) return (int) (max - 1);
					return (int) (n);
				case STBIR_EDGE_REFLECT:
				{
					if ((n) < (0))
					{
						if ((n) < (max)) return (int) (-n);
						else return (int) (max - 1);
					}
					if ((n) >= (max))
					{
						int max2 = (int) (max*2);
						if ((n) >= (max2)) return (int) (0);
						else return (int) (max2 - n - 1);
					}
					return (int) (n);
				}
				case STBIR_EDGE_WRAP:
					if ((n) >= (0)) return (int) (n%max);
					else
					{
						int m = (int) ((-n)%max);
						if (m != 0) m = (int) (max - m);
						return (int) (m);
					}
					return (int) (n);
				default:
					;
					return (int) (0);
			}

		}

		public static int stbir__edge_wrap(int edge, int n, int max)
		{
			if (((n) >= (0)) && ((n) < (max))) return (int) (n);
			return (int) (stbir__edge_wrap_slow((int) (edge), (int) (n), (int) (max)));
		}

		public static void stbir__calculate_sample_range_upsample(int n, float out_filter_radius, float scale_ratio,
			float out_shift, int* in_first_pixel, int* in_last_pixel, float* in_center_of_out)
		{
			float out_pixel_center = (float) (n) + 0.5f;
			float out_pixel_influence_lowerbound = (float) (out_pixel_center - out_filter_radius);
			float out_pixel_influence_upperbound = (float) (out_pixel_center + out_filter_radius);
			float in_pixel_influence_lowerbound = (float) ((out_pixel_influence_lowerbound + out_shift)/scale_ratio);
			float in_pixel_influence_upperbound = (float) ((out_pixel_influence_upperbound + out_shift)/scale_ratio);
			*in_center_of_out = (float) ((out_pixel_center + out_shift)/scale_ratio);
			*in_first_pixel = (int) ((int) (floor((double) (in_pixel_influence_lowerbound + 0.5))));
			*in_last_pixel = (int) ((int) (floor((double) (in_pixel_influence_upperbound - 0.5))));
		}

		public static void stbir__calculate_sample_range_downsample(int n, float in_pixels_radius, float scale_ratio,
			float out_shift, int* out_first_pixel, int* out_last_pixel, float* out_center_of_in)
		{
			float in_pixel_center = (float) (n) + 0.5f;
			float in_pixel_influence_lowerbound = (float) (in_pixel_center - in_pixels_radius);
			float in_pixel_influence_upperbound = (float) (in_pixel_center + in_pixels_radius);
			float out_pixel_influence_lowerbound = (float) (in_pixel_influence_lowerbound*scale_ratio - out_shift);
			float out_pixel_influence_upperbound = (float) (in_pixel_influence_upperbound*scale_ratio - out_shift);
			*out_center_of_in = (float) (in_pixel_center*scale_ratio - out_shift);
			*out_first_pixel = (int) ((int) (floor((double) (out_pixel_influence_lowerbound + 0.5))));
			*out_last_pixel = (int) ((int) (floor((double) (out_pixel_influence_upperbound - 0.5))));
		}

		public static void stbir__calculate_coefficients_upsample(stbir__info stbir_info, int filter, float scale,
			int in_first_pixel, int in_last_pixel, float in_center_of_out, stbir__contributors* contributor,
			float* coefficient_group)
		{
			int i;
			float total_filter = (float) (0);
			float filter_scale;
			contributor->n0 = (int) (in_first_pixel);
			contributor->n1 = (int) (in_last_pixel);
			for (i = (int) (0); i <= in_last_pixel - in_first_pixel; i++)
			{
				{
					float in_pixel_center = (float) (i + in_first_pixel) + 0.5f;
					coefficient_group[i] =
						(float) (stbir__filter_info_table[filter].kernel((float) (in_center_of_out - in_pixel_center), (float) (1/scale)));
					if (((i) == (0)) && (coefficient_group[i] == 0))
					{
						contributor->n0 = (int) (++in_first_pixel);
						i--;
						;
					}
					total_filter += (float) (coefficient_group[i]);
				}
			}
			filter_scale = (float) (1/total_filter);
			for (i = (int) (0); i <= in_last_pixel - in_first_pixel; i++)
			{
				coefficient_group[i] *= (float) (filter_scale);
			}
			for (i = (int) (in_last_pixel - in_first_pixel); (i) >= (0); i--)
			{
				{
					if ((coefficient_group[i]) != 0) break;
					contributor->n1 = (int) (contributor->n0 + i - 1);
				}
			}
		}

		public static void stbir__calculate_coefficients_downsample(stbir__info stbir_info, int filter, float scale_ratio,
			int out_first_pixel, int out_last_pixel, float out_center_of_in, stbir__contributors* contributor,
			float* coefficient_group)
		{
			int i;
			contributor->n0 = (int) (out_first_pixel);
			contributor->n1 = (int) (out_last_pixel);
			for (i = (int) (0); i <= out_last_pixel - out_first_pixel; i++)
			{
				{
					float out_pixel_center = (float) (i + out_first_pixel) + 0.5f;
					float x = (float) (out_pixel_center - out_center_of_in);
					coefficient_group[i] =
						(float) (stbir__filter_info_table[filter].kernel((float) (x), (float) (scale_ratio))*scale_ratio);
				}
			}
			for (i = (int) (out_last_pixel - out_first_pixel); (i) >= (0); i--)
			{
				{
					if ((coefficient_group[i]) != 0) break;
					contributor->n1 = (int) (contributor->n0 + i - 1);
				}
			}
		}

		public static void stbir__normalize_downsample_coefficients(stbir__info stbir_info, stbir__contributors* contributors,
			float* coefficients, int filter, float scale_ratio, float shift, int input_size, int output_size)
		{
			int num_contributors =
				(int) (stbir__get_contributors((float) (scale_ratio), (int) (filter), (int) (input_size), (int) (output_size)));
			int num_coefficients = (int) (stbir__get_coefficient_width((int) (filter), (float) (scale_ratio)));
			int i;
			int j;
			int skip;
			for (i = (int) (0); (i) < (output_size); i++)
			{
				{
					float scale;
					float total = (float) (0);
					for (j = (int) (0); (j) < (num_contributors); j++)
					{
						{
							if (((i) >= (contributors[j].n0)) && (i <= contributors[j].n1))
							{
								float coefficient =
									(float)
										(*
											stbir__get_coefficient(coefficients, (int) (filter), (float) (scale_ratio), (int) (j),
												(int) (i - contributors[j].n0)));
								total += (float) (coefficient);
							}
							else if ((i) < (contributors[j].n0)) break;
						}
					}
					;
					;
					scale = (float) (1/total);
					for (j = (int) (0); (j) < (num_contributors); j++)
					{
						{
							if (((i) >= (contributors[j].n0)) && (i <= contributors[j].n1))
								*
									stbir__get_coefficient(coefficients, (int) (filter), (float) (scale_ratio), (int) (j),
										(int) (i - contributors[j].n0)) *= (float) (scale);
							else if ((i) < (contributors[j].n0)) break;
						}
					}
				}
			}
			for (j = (int) (0); (j) < (num_contributors); j++)
			{
				{
					int range;
					int max;
					int width;
					skip = (int) (0);
					while ((*stbir__get_coefficient(coefficients, (int) (filter), (float) (scale_ratio), (int) (j), (int) (skip))) ==
					       (0))
					{
						skip++;
					}
					contributors[j].n0 += (int) (skip);
					while ((contributors[j].n0) < (0))
					{
						{
							contributors[j].n0++;
							skip++;
						}
					}
					range = (int) (contributors[j].n1 - contributors[j].n0 + 1);
					max = (int) (stbir__min((int) (num_coefficients), (int) (range)));
					width = (int) (stbir__get_coefficient_width((int) (filter), (float) (scale_ratio)));
					for (i = (int) (0); (i) < (max); i++)
					{
						{
							if ((i + skip) >= (width)) break;
							*stbir__get_coefficient(coefficients, (int) (filter), (float) (scale_ratio), (int) (j), (int) (i)) =
								(float)
									(*stbir__get_coefficient(coefficients, (int) (filter), (float) (scale_ratio), (int) (j), (int) (i + skip)));
						}
					}
					;
				}
			}
			for (i = (int) (0); (i) < (num_contributors); i++)
			{
				contributors[i].n1 = (int) (stbir__min((int) (contributors[i].n1), (int) (output_size - 1)));
			}
		}

		public static void stbir__calculate_filters(stbir__info stbir_info, stbir__contributors* contributors,
			float* coefficients, int filter, float scale_ratio, float shift, int input_size, int output_size)
		{
			int n;
			int total_contributors =
				(int) (stbir__get_contributors((float) (scale_ratio), (int) (filter), (int) (input_size), (int) (output_size)));
			if ((stbir__use_upsampling((float) (scale_ratio))) != 0)
			{
				float out_pixels_radius = (float) (stbir__filter_info_table[filter].support((float) (1/scale_ratio))*scale_ratio);
				for (n = (int) (0); (n) < (total_contributors); n++)
				{
					{
						float in_center_of_out;
						int in_first_pixel;
						int in_last_pixel;
						stbir__calculate_sample_range_upsample((int) (n), (float) (out_pixels_radius), (float) (scale_ratio),
							(float) (shift), &in_first_pixel, &in_last_pixel, &in_center_of_out);
						stbir__calculate_coefficients_upsample(stbir_info, (int) (filter), (float) (scale_ratio), (int) (in_first_pixel),
							(int) (in_last_pixel), (float) (in_center_of_out), stbir__get_contributor(contributors, (int) (n)),
							stbir__get_coefficient(coefficients, (int) (filter), (float) (scale_ratio), (int) (n), (int) (0)));
					}
				}
			}
			else
			{
				float in_pixels_radius = (float) (stbir__filter_info_table[filter].support((float) (scale_ratio))/scale_ratio);
				for (n = (int) (0); (n) < (total_contributors); n++)
				{
					{
						float out_center_of_in;
						int out_first_pixel;
						int out_last_pixel;
						int n_adjusted = (int) (n - stbir__get_filter_pixel_margin((int) (filter), (float) (scale_ratio)));
						stbir__calculate_sample_range_downsample((int) (n_adjusted), (float) (in_pixels_radius), (float) (scale_ratio),
							(float) (shift), &out_first_pixel, &out_last_pixel, &out_center_of_in);
						stbir__calculate_coefficients_downsample(stbir_info, (int) (filter), (float) (scale_ratio),
							(int) (out_first_pixel), (int) (out_last_pixel), (float) (out_center_of_in),
							stbir__get_contributor(contributors, (int) (n)),
							stbir__get_coefficient(coefficients, (int) (filter), (float) (scale_ratio), (int) (n), (int) (0)));
					}
				}
				stbir__normalize_downsample_coefficients(stbir_info, contributors, coefficients, (int) (filter),
					(float) (scale_ratio), (float) (shift), (int) (input_size), (int) (output_size));
			}

		}

		public static float* stbir__get_decode_buffer(stbir__info stbir_info)
		{
			return &stbir_info.decode_buffer[stbir_info.horizontal_filter_pixel_margin*stbir_info.channels];
		}

		public static void stbir__decode_scanline(stbir__info stbir_info, int n)
		{
			int c;
			int channels = (int) (stbir_info.channels);
			int alpha_channel = (int) (stbir_info.alpha_channel);
			int type = (int) (stbir_info.type);
			int colorspace = (int) (stbir_info.colorspace);
			int input_w = (int) (stbir_info.input_w);
			ulong input_stride_bytes = (ulong) (stbir_info.input_stride_bytes);
			float* decode_buffer = stbir__get_decode_buffer(stbir_info);
			int edge_horizontal = (int) (stbir_info.edge_horizontal);
			int edge_vertical = (int) (stbir_info.edge_vertical);
			ulong in_buffer_row_offset =
				(ulong) (stbir__edge_wrap((int) (edge_vertical), (int) (n), (int) (stbir_info.input_h))*(int)input_stride_bytes);
			void* input_data = (sbyte*) (stbir_info.input_data) + in_buffer_row_offset;
			int max_x = (int) (input_w + stbir_info.horizontal_filter_pixel_margin);
			int decode = (int) ((type)*(STBIR_MAX_COLORSPACES) + (colorspace));
			int x = (int) (-stbir_info.horizontal_filter_pixel_margin);
			if (((edge_vertical) == (STBIR_EDGE_ZERO)) && (((n) < (0)) || ((n) >= (stbir_info.input_h))))
			{
				for (; (x) < (max_x); x++)
				{
					for (c = (int) (0); (c) < (channels); c++)
					{
						decode_buffer[x*channels + c] = (float) (0);
					}
				}
				return;
			}

			switch (decode)
			{
				case ((STBIR_TYPE_UINT8)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (; (x) < (max_x); x++)
					{
						{
							int decode_pixel_index = (int) (x*channels);
							int input_pixel_index = (int) (stbir__edge_wrap((int) (edge_horizontal), (int) (x), (int) (input_w))*channels);
							for (c = (int) (0); (c) < (channels); c++)
							{
								decode_buffer[decode_pixel_index + c] = (float) (((float) (((byte*) (input_data))[input_pixel_index + c]))/255);
							}
						}
					}
					break;
				case ((STBIR_TYPE_UINT8)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (; (x) < (max_x); x++)
					{
						{
							int decode_pixel_index = (int) (x*channels);
							int input_pixel_index = (int) (stbir__edge_wrap((int) (edge_horizontal), (int) (x), (int) (input_w))*channels);
							for (c = (int) (0); (c) < (channels); c++)
							{
								decode_buffer[decode_pixel_index + c] =
									(float) (((float*) (stbir__srgb_uchar_to_linear_float))[((byte*) (input_data))[input_pixel_index + c]]);
							}
							if ((stbir_info.flags & (1 << 1)) == 0)
								decode_buffer[decode_pixel_index + alpha_channel] =
									(float) (((float) (((byte*) (input_data))[input_pixel_index + alpha_channel]))/255);
						}
					}
					break;
				case ((STBIR_TYPE_UINT16)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (; (x) < (max_x); x++)
					{
						{
							int decode_pixel_index = (int) (x*channels);
							int input_pixel_index = (int) (stbir__edge_wrap((int) (edge_horizontal), (int) (x), (int) (input_w))*channels);
							for (c = (int) (0); (c) < (channels); c++)
							{
								decode_buffer[decode_pixel_index + c] =
									(float) (((float) (((ushort*) (input_data))[input_pixel_index + c]))/65535);
							}
						}
					}
					break;
				case ((STBIR_TYPE_UINT16)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (; (x) < (max_x); x++)
					{
						{
							int decode_pixel_index = (int) (x*channels);
							int input_pixel_index = (int) (stbir__edge_wrap((int) (edge_horizontal), (int) (x), (int) (input_w))*channels);
							for (c = (int) (0); (c) < (channels); c++)
							{
								decode_buffer[decode_pixel_index + c] =
									(float) (stbir__srgb_to_linear((float) (((float) (((ushort*) (input_data))[input_pixel_index + c]))/65535)));
							}
							if ((stbir_info.flags & (1 << 1)) == 0)
								decode_buffer[decode_pixel_index + alpha_channel] =
									(float) (((float) (((ushort*) (input_data))[input_pixel_index + alpha_channel]))/65535);
						}
					}
					break;
				case ((STBIR_TYPE_UINT32)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (; (x) < (max_x); x++)
					{
						{
							int decode_pixel_index = (int) (x*channels);
							int input_pixel_index = (int) (stbir__edge_wrap((int) (edge_horizontal), (int) (x), (int) (input_w))*channels);
							for (c = (int) (0); (c) < (channels); c++)
							{
								decode_buffer[decode_pixel_index + c] =
									(float) ((float) (((double) (((uint*) (input_data))[input_pixel_index + c]))/4294967295));
							}
						}
					}
					break;
				case ((STBIR_TYPE_UINT32)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (; (x) < (max_x); x++)
					{
						{
							int decode_pixel_index = (int) (x*channels);
							int input_pixel_index = (int) (stbir__edge_wrap((int) (edge_horizontal), (int) (x), (int) (input_w))*channels);
							for (c = (int) (0); (c) < (channels); c++)
							{
								decode_buffer[decode_pixel_index + c] =
									(float)
										(stbir__srgb_to_linear((float) (((double) (((uint*) (input_data))[input_pixel_index + c]))/4294967295)));
							}
							if ((stbir_info.flags & (1 << 1)) == 0)
								decode_buffer[decode_pixel_index + alpha_channel] =
									(float) ((float) (((double) (((uint*) (input_data))[input_pixel_index + alpha_channel]))/4294967295));
						}
					}
					break;
				case ((STBIR_TYPE_FLOAT)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (; (x) < (max_x); x++)
					{
						{
							int decode_pixel_index = (int) (x*channels);
							int input_pixel_index = (int) (stbir__edge_wrap((int) (edge_horizontal), (int) (x), (int) (input_w))*channels);
							for (c = (int) (0); (c) < (channels); c++)
							{
								decode_buffer[decode_pixel_index + c] = (float) (((float*) (input_data))[input_pixel_index + c]);
							}
						}
					}
					break;
				case ((STBIR_TYPE_FLOAT)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (; (x) < (max_x); x++)
					{
						{
							int decode_pixel_index = (int) (x*channels);
							int input_pixel_index = (int) (stbir__edge_wrap((int) (edge_horizontal), (int) (x), (int) (input_w))*channels);
							for (c = (int) (0); (c) < (channels); c++)
							{
								decode_buffer[decode_pixel_index + c] =
									(float) (stbir__srgb_to_linear((float) (((float*) (input_data))[input_pixel_index + c])));
							}
							if ((stbir_info.flags & (1 << 1)) == 0)
								decode_buffer[decode_pixel_index + alpha_channel] =
									(float) (((float*) (input_data))[input_pixel_index + alpha_channel]);
						}
					}
					break;
				default:
					;
					break;
			}

			if ((stbir_info.flags & (1 << 0)) == 0)
			{
				for (x = (int) (-stbir_info.horizontal_filter_pixel_margin); (x) < (max_x); x++)
				{
					{
						int decode_pixel_index = (int) (x*channels);
						float alpha = (float) (decode_buffer[decode_pixel_index + alpha_channel]);
						if (stbir_info.type != STBIR_TYPE_FLOAT)
						{
							alpha += (float) ((float) (1)/(1 << 20)/(1 << 20)/(1 << 20)/(1 << 20));
							decode_buffer[decode_pixel_index + alpha_channel] = (float) (alpha);
						}
						for (c = (int) (0); (c) < (channels); c++)
						{
							{
								if ((c) == (alpha_channel)) ;
								decode_buffer[decode_pixel_index + c] *= (float) (alpha);
							}
						}
					}
				}
			}

			if ((edge_horizontal) == (STBIR_EDGE_ZERO))
			{
				for (x = (int) (-stbir_info.horizontal_filter_pixel_margin); (x) < (0); x++)
				{
					{
						for (c = (int) (0); (c) < (channels); c++)
						{
							decode_buffer[x*channels + c] = (float) (0);
						}
					}
				}
				for (x = (int) (input_w); (x) < (max_x); x++)
				{
					{
						for (c = (int) (0); (c) < (channels); c++)
						{
							decode_buffer[x*channels + c] = (float) (0);
						}
					}
				}
			}

		}

		public static float* stbir__get_ring_buffer_entry(float* ring_buffer, int index, int ring_buffer_length)
		{
			return &ring_buffer[index*ring_buffer_length];
		}

		public static float* stbir__add_empty_ring_buffer_entry(stbir__info stbir_info, int n)
		{
			int ring_buffer_index;
			float* ring_buffer;
			stbir_info.ring_buffer_last_scanline = (int) (n);
			if ((stbir_info.ring_buffer_begin_index) < (0))
			{
				ring_buffer_index = (int) (stbir_info.ring_buffer_begin_index = (int) (0));
				stbir_info.ring_buffer_first_scanline = (int) (n);
			}
			else
			{
				ring_buffer_index =
					(int)
						((stbir_info.ring_buffer_begin_index +
						  (stbir_info.ring_buffer_last_scanline - stbir_info.ring_buffer_first_scanline))%
						 stbir_info.ring_buffer_num_entries);
				;
			}

			ring_buffer = stbir__get_ring_buffer_entry(stbir_info.ring_buffer, (int) (ring_buffer_index),
				(int) (stbir_info.ring_buffer_length_bytes/sizeof (ulong)));
			memset(ring_buffer, (int) (0), (ulong) (stbir_info.ring_buffer_length_bytes));
			return ring_buffer;
		}

		public static void stbir__resample_horizontal_upsample(stbir__info stbir_info, int n, float* output_buffer)
		{
			int x;
			int k;
			int output_w = (int) (stbir_info.output_w);
			int kernel_pixel_width = (int) (stbir_info.horizontal_filter_pixel_width);
			int channels = (int) (stbir_info.channels);
			float* decode_buffer = stbir__get_decode_buffer(stbir_info);
			stbir__contributors* horizontal_contributors = stbir_info.horizontal_contributors;
			float* horizontal_coefficients = stbir_info.horizontal_coefficients;
			int coefficient_width = (int) (stbir_info.horizontal_coefficient_width);
			for (x = (int) (0); (x) < (output_w); x++)
			{
				{
					int n0 = (int) (horizontal_contributors[x].n0);
					int n1 = (int) (horizontal_contributors[x].n1);
					int out_pixel_index = (int) (x*channels);
					int coefficient_group = (int) (coefficient_width*x);
					int coefficient_counter = (int) (0);
					;
					;
					;
					;
					;
					switch (channels)
					{
						case 1:
							for (k = (int) (n0); k <= n1; k++)
							{
								{
									int in_pixel_index = (int) (k*1);
									float coefficient = (float) (horizontal_coefficients[coefficient_group + coefficient_counter++]);
									;
									output_buffer[out_pixel_index + 0] += (float) (decode_buffer[in_pixel_index + 0]*coefficient);
								}
							}
							break;
						case 2:
							for (k = (int) (n0); k <= n1; k++)
							{
								{
									int in_pixel_index = (int) (k*2);
									float coefficient = (float) (horizontal_coefficients[coefficient_group + coefficient_counter++]);
									;
									output_buffer[out_pixel_index + 0] += (float) (decode_buffer[in_pixel_index + 0]*coefficient);
									output_buffer[out_pixel_index + 1] += (float) (decode_buffer[in_pixel_index + 1]*coefficient);
								}
							}
							break;
						case 3:
							for (k = (int) (n0); k <= n1; k++)
							{
								{
									int in_pixel_index = (int) (k*3);
									float coefficient = (float) (horizontal_coefficients[coefficient_group + coefficient_counter++]);
									;
									output_buffer[out_pixel_index + 0] += (float) (decode_buffer[in_pixel_index + 0]*coefficient);
									output_buffer[out_pixel_index + 1] += (float) (decode_buffer[in_pixel_index + 1]*coefficient);
									output_buffer[out_pixel_index + 2] += (float) (decode_buffer[in_pixel_index + 2]*coefficient);
								}
							}
							break;
						case 4:
							for (k = (int) (n0); k <= n1; k++)
							{
								{
									int in_pixel_index = (int) (k*4);
									float coefficient = (float) (horizontal_coefficients[coefficient_group + coefficient_counter++]);
									;
									output_buffer[out_pixel_index + 0] += (float) (decode_buffer[in_pixel_index + 0]*coefficient);
									output_buffer[out_pixel_index + 1] += (float) (decode_buffer[in_pixel_index + 1]*coefficient);
									output_buffer[out_pixel_index + 2] += (float) (decode_buffer[in_pixel_index + 2]*coefficient);
									output_buffer[out_pixel_index + 3] += (float) (decode_buffer[in_pixel_index + 3]*coefficient);
								}
							}
							break;
						default:
							for (k = (int) (n0); k <= n1; k++)
							{
								{
									int in_pixel_index = (int) (k*channels);
									float coefficient = (float) (horizontal_coefficients[coefficient_group + coefficient_counter++]);
									int c;
									;
									for (c = (int) (0); (c) < (channels); c++)
									{
										output_buffer[out_pixel_index + c] += (float) (decode_buffer[in_pixel_index + c]*coefficient);
									}
								}
							}
							break;
					}
				}
			}
		}

		public static void stbir__resample_horizontal_downsample(stbir__info stbir_info, int n, float* output_buffer)
		{
			int x;
			int k;
			int input_w = (int) (stbir_info.input_w);
			int output_w = (int) (stbir_info.output_w);
			int kernel_pixel_width = (int) (stbir_info.horizontal_filter_pixel_width);
			int channels = (int) (stbir_info.channels);
			float* decode_buffer = stbir__get_decode_buffer(stbir_info);
			stbir__contributors* horizontal_contributors = stbir_info.horizontal_contributors;
			float* horizontal_coefficients = stbir_info.horizontal_coefficients;
			int coefficient_width = (int) (stbir_info.horizontal_coefficient_width);
			int filter_pixel_margin = (int) (stbir_info.horizontal_filter_pixel_margin);
			int max_x = (int) (input_w + filter_pixel_margin*2);
			switch (channels)
			{
				case 1:
					for (x = (int) (0); (x) < (max_x); x++)
					{
						{
							int n0 = (int) (horizontal_contributors[x].n0);
							int n1 = (int) (horizontal_contributors[x].n1);
							int in_x = (int) (x - filter_pixel_margin);
							int in_pixel_index = (int) (in_x*1);
							int max_n = (int) (n1);
							int coefficient_group = (int) (coefficient_width*x);
							for (k = (int) (n0); k <= max_n; k++)
							{
								{
									int out_pixel_index = (int) (k*1);
									float coefficient = (float) (horizontal_coefficients[coefficient_group + k - n0]);
									;
									output_buffer[out_pixel_index + 0] += (float) (decode_buffer[in_pixel_index + 0]*coefficient);
								}
							}
						}
					}
					break;
				case 2:
					for (x = (int) (0); (x) < (max_x); x++)
					{
						{
							int n0 = (int) (horizontal_contributors[x].n0);
							int n1 = (int) (horizontal_contributors[x].n1);
							int in_x = (int) (x - filter_pixel_margin);
							int in_pixel_index = (int) (in_x*2);
							int max_n = (int) (n1);
							int coefficient_group = (int) (coefficient_width*x);
							for (k = (int) (n0); k <= max_n; k++)
							{
								{
									int out_pixel_index = (int) (k*2);
									float coefficient = (float) (horizontal_coefficients[coefficient_group + k - n0]);
									;
									output_buffer[out_pixel_index + 0] += (float) (decode_buffer[in_pixel_index + 0]*coefficient);
									output_buffer[out_pixel_index + 1] += (float) (decode_buffer[in_pixel_index + 1]*coefficient);
								}
							}
						}
					}
					break;
				case 3:
					for (x = (int) (0); (x) < (max_x); x++)
					{
						{
							int n0 = (int) (horizontal_contributors[x].n0);
							int n1 = (int) (horizontal_contributors[x].n1);
							int in_x = (int) (x - filter_pixel_margin);
							int in_pixel_index = (int) (in_x*3);
							int max_n = (int) (n1);
							int coefficient_group = (int) (coefficient_width*x);
							for (k = (int) (n0); k <= max_n; k++)
							{
								{
									int out_pixel_index = (int) (k*3);
									float coefficient = (float) (horizontal_coefficients[coefficient_group + k - n0]);
									;
									output_buffer[out_pixel_index + 0] += (float) (decode_buffer[in_pixel_index + 0]*coefficient);
									output_buffer[out_pixel_index + 1] += (float) (decode_buffer[in_pixel_index + 1]*coefficient);
									output_buffer[out_pixel_index + 2] += (float) (decode_buffer[in_pixel_index + 2]*coefficient);
								}
							}
						}
					}
					break;
				case 4:
					for (x = (int) (0); (x) < (max_x); x++)
					{
						{
							int n0 = (int) (horizontal_contributors[x].n0);
							int n1 = (int) (horizontal_contributors[x].n1);
							int in_x = (int) (x - filter_pixel_margin);
							int in_pixel_index = (int) (in_x*4);
							int max_n = (int) (n1);
							int coefficient_group = (int) (coefficient_width*x);
							for (k = (int) (n0); k <= max_n; k++)
							{
								{
									int out_pixel_index = (int) (k*4);
									float coefficient = (float) (horizontal_coefficients[coefficient_group + k - n0]);
									;
									output_buffer[out_pixel_index + 0] += (float) (decode_buffer[in_pixel_index + 0]*coefficient);
									output_buffer[out_pixel_index + 1] += (float) (decode_buffer[in_pixel_index + 1]*coefficient);
									output_buffer[out_pixel_index + 2] += (float) (decode_buffer[in_pixel_index + 2]*coefficient);
									output_buffer[out_pixel_index + 3] += (float) (decode_buffer[in_pixel_index + 3]*coefficient);
								}
							}
						}
					}
					break;
				default:
					for (x = (int) (0); (x) < (max_x); x++)
					{
						{
							int n0 = (int) (horizontal_contributors[x].n0);
							int n1 = (int) (horizontal_contributors[x].n1);
							int in_x = (int) (x - filter_pixel_margin);
							int in_pixel_index = (int) (in_x*channels);
							int max_n = (int) (n1);
							int coefficient_group = (int) (coefficient_width*x);
							for (k = (int) (n0); k <= max_n; k++)
							{
								{
									int c;
									int out_pixel_index = (int) (k*channels);
									float coefficient = (float) (horizontal_coefficients[coefficient_group + k - n0]);
									;
									for (c = (int) (0); (c) < (channels); c++)
									{
										output_buffer[out_pixel_index + c] += (float) (decode_buffer[in_pixel_index + c]*coefficient);
									}
								}
							}
						}
					}
					break;
			}

		}

		public static void stbir__decode_and_resample_upsample(stbir__info stbir_info, int n)
		{
			stbir__decode_scanline(stbir_info, (int) (n));
			if ((stbir__use_width_upsampling(stbir_info)) != 0)
				stbir__resample_horizontal_upsample(stbir_info, (int) (n), stbir__add_empty_ring_buffer_entry(stbir_info, (int) (n)));
			else
				stbir__resample_horizontal_downsample(stbir_info, (int) (n),
					stbir__add_empty_ring_buffer_entry(stbir_info, (int) (n)));
		}

		public static void stbir__decode_and_resample_downsample(stbir__info stbir_info, int n)
		{
			stbir__decode_scanline(stbir_info, (int) (n));
			memset(stbir_info.horizontal_buffer, (int) (0), (ulong) (stbir_info.output_w*stbir_info.channels*sizeof (ulong)));
			if ((stbir__use_width_upsampling(stbir_info)) != 0)
				stbir__resample_horizontal_upsample(stbir_info, (int) (n), stbir_info.horizontal_buffer);
			else stbir__resample_horizontal_downsample(stbir_info, (int) (n), stbir_info.horizontal_buffer);
		}

		public static float* stbir__get_ring_buffer_scanline(int get_scanline, float* ring_buffer, int begin_index,
			int first_scanline, int ring_buffer_num_entries, int ring_buffer_length)
		{
			int ring_buffer_index = (int) ((begin_index + (get_scanline - first_scanline))%ring_buffer_num_entries);
			return stbir__get_ring_buffer_entry(ring_buffer, (int) (ring_buffer_index), (int) (ring_buffer_length));
		}

		public static void stbir__encode_scanline(stbir__info stbir_info, int num_pixels, void* output_buffer,
			float* encode_buffer, int channels, int alpha_channel, int decode)
		{
			int x;
			int n;
			int num_nonalpha;
			ushort* nonalpha = stackalloc ushort[64];
			if ((stbir_info.flags & (1 << 0)) == 0)
			{
				for (x = (int) (0); (x) < (num_pixels); ++x)
				{
					{
						int pixel_index = (int) (x*channels);
						float alpha = (float) (encode_buffer[pixel_index + alpha_channel]);
						float reciprocal_alpha = (float) ((alpha) != 0 ? 1.0f/alpha : 0);
						for (n = (int) (0); (n) < (channels); n++)
						{
							if (n != alpha_channel) encode_buffer[pixel_index + n] *= (float) (reciprocal_alpha);
						}
					}
				}
			}

			for (x = (int) (0) , num_nonalpha = (int) (0); (x) < (channels); ++x)
			{
				if ((x != alpha_channel) || (stbir_info.flags & (1 << 1)) != 0) ((ushort*) (nonalpha))[num_nonalpha++] = (ushort) (x);
			}
			switch (decode)
			{
				case ((STBIR_TYPE_UINT8)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (x = (int) (0); (x) < (num_pixels); ++x)
					{
						{
							int pixel_index = (int) (x*channels);
							for (n = (int) (0); (n) < (channels); n++)
							{
								{
									int index = (int) (pixel_index + n);
									((byte*) (output_buffer))[index] =
										(byte) ((byte) ((int) ((stbir__saturate((float) (encode_buffer[index]))*255) + 0.5)));
								}
							}
						}
					}
					break;
				case ((STBIR_TYPE_UINT8)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (x = (int) (0); (x) < (num_pixels); ++x)
					{
						{
							int pixel_index = (int) (x*channels);
							for (n = (int) (0); (n) < (num_nonalpha); n++)
							{
								{
									int index = (int) (pixel_index + ((ushort*) (nonalpha))[n]);
									((byte*) (output_buffer))[index] = (byte) (stbir__linear_to_srgb_uchar((float) (encode_buffer[index])));
								}
							}
							if ((stbir_info.flags & (1 << 1)) == 0)
								((byte*) (output_buffer))[pixel_index + alpha_channel] =
									(byte) ((byte) ((int) ((stbir__saturate((float) (encode_buffer[pixel_index + alpha_channel]))*255) + 0.5)));
						}
					}
					break;
				case ((STBIR_TYPE_UINT16)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (x = (int) (0); (x) < (num_pixels); ++x)
					{
						{
							int pixel_index = (int) (x*channels);
							for (n = (int) (0); (n) < (channels); n++)
							{
								{
									int index = (int) (pixel_index + n);
									((ushort*) (output_buffer))[index] =
										(ushort) ((ushort) ((int) ((stbir__saturate((float) (encode_buffer[index]))*65535) + 0.5)));
								}
							}
						}
					}
					break;
				case ((STBIR_TYPE_UINT16)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (x = (int) (0); (x) < (num_pixels); ++x)
					{
						{
							int pixel_index = (int) (x*channels);
							for (n = (int) (0); (n) < (num_nonalpha); n++)
							{
								{
									int index = (int) (pixel_index + ((ushort*) (nonalpha))[n]);
									((ushort*) (output_buffer))[index] =
										(ushort)
											((ushort)
												((int) ((stbir__linear_to_srgb((float) (stbir__saturate((float) (encode_buffer[index]))))*65535) + 0.5)));
								}
							}
							if ((stbir_info.flags & (1 << 1)) == 0)
								((ushort*) (output_buffer))[pixel_index + alpha_channel] =
									(ushort)
										((ushort) ((int) ((stbir__saturate((float) (encode_buffer[pixel_index + alpha_channel]))*65535) + 0.5)));
						}
					}
					break;
				case ((STBIR_TYPE_UINT32)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (x = (int) (0); (x) < (num_pixels); ++x)
					{
						{
							int pixel_index = (int) (x*channels);
							for (n = (int) (0); (n) < (channels); n++)
							{
								{
									int index = (int) (pixel_index + n);
									((uint*) (output_buffer))[index] =
										(uint) ((uint) ((((double) (stbir__saturate((float) (encode_buffer[index]))))*4294967295) + 0.5));
								}
							}
						}
					}
					break;
				case ((STBIR_TYPE_UINT32)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (x = (int) (0); (x) < (num_pixels); ++x)
					{
						{
							int pixel_index = (int) (x*channels);
							for (n = (int) (0); (n) < (num_nonalpha); n++)
							{
								{
									int index = (int) (pixel_index + ((ushort*) (nonalpha))[n]);
									((uint*) (output_buffer))[index] =
										(uint)
											((uint)
												((((double) (stbir__linear_to_srgb((float) (stbir__saturate((float) (encode_buffer[index]))))))*4294967295) +
												 0.5));
								}
							}
							if ((stbir_info.flags & (1 << 1)) == 0)
								((uint*) (output_buffer))[pixel_index + alpha_channel] =
									(uint)
										((uint)
											((int)
												((((double) (stbir__saturate((float) (encode_buffer[pixel_index + alpha_channel]))))*4294967295) + 0.5)));
						}
					}
					break;
				case ((STBIR_TYPE_FLOAT)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_LINEAR)):
					for (x = (int) (0); (x) < (num_pixels); ++x)
					{
						{
							int pixel_index = (int) (x*channels);
							for (n = (int) (0); (n) < (channels); n++)
							{
								{
									int index = (int) (pixel_index + n);
									((float*) (output_buffer))[index] = (float) (encode_buffer[index]);
								}
							}
						}
					}
					break;
				case ((STBIR_TYPE_FLOAT)*(STBIR_MAX_COLORSPACES) + (STBIR_COLORSPACE_SRGB)):
					for (x = (int) (0); (x) < (num_pixels); ++x)
					{
						{
							int pixel_index = (int) (x*channels);
							for (n = (int) (0); (n) < (num_nonalpha); n++)
							{
								{
									int index = (int) (pixel_index + ((ushort*) (nonalpha))[n]);
									((float*) (output_buffer))[index] = (float) (stbir__linear_to_srgb((float) (encode_buffer[index])));
								}
							}
							if ((stbir_info.flags & (1 << 1)) == 0)
								((float*) (output_buffer))[pixel_index + alpha_channel] = (float) (encode_buffer[pixel_index + alpha_channel]);
						}
					}
					break;
				default:
					;
					break;
			}

		}

		public static void stbir__resample_vertical_upsample(stbir__info stbir_info, int n, int in_first_scanline,
			int in_last_scanline, float in_center_of_out)
		{
			int x;
			int k;
			int output_w = (int) (stbir_info.output_w);
			stbir__contributors* vertical_contributors = stbir_info.vertical_contributors;
			float* vertical_coefficients = stbir_info.vertical_coefficients;
			int channels = (int) (stbir_info.channels);
			int alpha_channel = (int) (stbir_info.alpha_channel);
			int type = (int) (stbir_info.type);
			int colorspace = (int) (stbir_info.colorspace);
			int ring_buffer_entries = (int) (stbir_info.ring_buffer_num_entries);
			void* output_data = stbir_info.output_data;
			float* encode_buffer = stbir_info.encode_buffer;
			int decode = (int) ((type)*(STBIR_MAX_COLORSPACES) + (colorspace));
			int coefficient_width = (int) (stbir_info.vertical_coefficient_width);
			int coefficient_counter;
			int contributor = (int) (n);
			float* ring_buffer = stbir_info.ring_buffer;
			int ring_buffer_begin_index = (int) (stbir_info.ring_buffer_begin_index);
			int ring_buffer_first_scanline = (int) (stbir_info.ring_buffer_first_scanline);
			int ring_buffer_last_scanline = (int) (stbir_info.ring_buffer_last_scanline);
			int ring_buffer_length = (int) (stbir_info.ring_buffer_length_bytes/sizeof (ulong));
			int n0;
			int n1;
			int output_row_start;
			int coefficient_group = (int) (coefficient_width*contributor);
			n0 = (int) (vertical_contributors[contributor].n0);
			n1 = (int) (vertical_contributors[contributor].n1);
			output_row_start = (int) (n*stbir_info.output_stride_bytes);
			memset(encode_buffer, (int) (0), (ulong) (output_w*sizeof (ulong)*channels));
			coefficient_counter = (int) (0);
			switch (channels)
			{
				case 1:
					for (k = (int) (n0); k <= n1; k++)
					{
						{
							int coefficient_index = (int) (coefficient_counter++);
							float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int) (k), ring_buffer,
								(int) (ring_buffer_begin_index), (int) (ring_buffer_first_scanline), (int) (ring_buffer_entries),
								(int) (ring_buffer_length));
							float coefficient = (float) (vertical_coefficients[coefficient_group + coefficient_index]);
							for (x = (int) (0); (x) < (output_w); ++x)
							{
								{
									int in_pixel_index = (int) (x*1);
									encode_buffer[in_pixel_index + 0] += (float) (ring_buffer_entry[in_pixel_index + 0]*coefficient);
								}
							}
						}
					}
					break;
				case 2:
					for (k = (int) (n0); k <= n1; k++)
					{
						{
							int coefficient_index = (int) (coefficient_counter++);
							float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int) (k), ring_buffer,
								(int) (ring_buffer_begin_index), (int) (ring_buffer_first_scanline), (int) (ring_buffer_entries),
								(int) (ring_buffer_length));
							float coefficient = (float) (vertical_coefficients[coefficient_group + coefficient_index]);
							for (x = (int) (0); (x) < (output_w); ++x)
							{
								{
									int in_pixel_index = (int) (x*2);
									encode_buffer[in_pixel_index + 0] += (float) (ring_buffer_entry[in_pixel_index + 0]*coefficient);
									encode_buffer[in_pixel_index + 1] += (float) (ring_buffer_entry[in_pixel_index + 1]*coefficient);
								}
							}
						}
					}
					break;
				case 3:
					for (k = (int) (n0); k <= n1; k++)
					{
						{
							int coefficient_index = (int) (coefficient_counter++);
							float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int) (k), ring_buffer,
								(int) (ring_buffer_begin_index), (int) (ring_buffer_first_scanline), (int) (ring_buffer_entries),
								(int) (ring_buffer_length));
							float coefficient = (float) (vertical_coefficients[coefficient_group + coefficient_index]);
							for (x = (int) (0); (x) < (output_w); ++x)
							{
								{
									int in_pixel_index = (int) (x*3);
									encode_buffer[in_pixel_index + 0] += (float) (ring_buffer_entry[in_pixel_index + 0]*coefficient);
									encode_buffer[in_pixel_index + 1] += (float) (ring_buffer_entry[in_pixel_index + 1]*coefficient);
									encode_buffer[in_pixel_index + 2] += (float) (ring_buffer_entry[in_pixel_index + 2]*coefficient);
								}
							}
						}
					}
					break;
				case 4:
					for (k = (int) (n0); k <= n1; k++)
					{
						{
							int coefficient_index = (int) (coefficient_counter++);
							float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int) (k), ring_buffer,
								(int) (ring_buffer_begin_index), (int) (ring_buffer_first_scanline), (int) (ring_buffer_entries),
								(int) (ring_buffer_length));
							float coefficient = (float) (vertical_coefficients[coefficient_group + coefficient_index]);
							for (x = (int) (0); (x) < (output_w); ++x)
							{
								{
									int in_pixel_index = (int) (x*4);
									encode_buffer[in_pixel_index + 0] += (float) (ring_buffer_entry[in_pixel_index + 0]*coefficient);
									encode_buffer[in_pixel_index + 1] += (float) (ring_buffer_entry[in_pixel_index + 1]*coefficient);
									encode_buffer[in_pixel_index + 2] += (float) (ring_buffer_entry[in_pixel_index + 2]*coefficient);
									encode_buffer[in_pixel_index + 3] += (float) (ring_buffer_entry[in_pixel_index + 3]*coefficient);
								}
							}
						}
					}
					break;
				default:
					for (k = (int) (n0); k <= n1; k++)
					{
						{
							int coefficient_index = (int) (coefficient_counter++);
							float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int) (k), ring_buffer,
								(int) (ring_buffer_begin_index), (int) (ring_buffer_first_scanline), (int) (ring_buffer_entries),
								(int) (ring_buffer_length));
							float coefficient = (float) (vertical_coefficients[coefficient_group + coefficient_index]);
							for (x = (int) (0); (x) < (output_w); ++x)
							{
								{
									int in_pixel_index = (int) (x*channels);
									int c;
									for (c = (int) (0); (c) < (channels); c++)
									{
										encode_buffer[in_pixel_index + c] += (float) (ring_buffer_entry[in_pixel_index + c]*coefficient);
									}
								}
							}
						}
					}
					break;
			}

			stbir__encode_scanline(stbir_info, (int) (output_w), (sbyte*) (output_data) + output_row_start, encode_buffer,
				(int) (channels), (int) (alpha_channel), (int) (decode));
		}

		public static void stbir__resample_vertical_downsample(stbir__info stbir_info, int n, int in_first_scanline,
			int in_last_scanline, float in_center_of_out)
		{
			int x;
			int k;
			int output_w = (int) (stbir_info.output_w);
			int output_h = (int) (stbir_info.output_h);
			stbir__contributors* vertical_contributors = stbir_info.vertical_contributors;
			float* vertical_coefficients = stbir_info.vertical_coefficients;
			int channels = (int) (stbir_info.channels);
			int ring_buffer_entries = (int) (stbir_info.ring_buffer_num_entries);
			void* output_data = stbir_info.output_data;
			float* horizontal_buffer = stbir_info.horizontal_buffer;
			int coefficient_width = (int) (stbir_info.vertical_coefficient_width);
			int contributor = (int) (n + stbir_info.vertical_filter_pixel_margin);
			float* ring_buffer = stbir_info.ring_buffer;
			int ring_buffer_begin_index = (int) (stbir_info.ring_buffer_begin_index);
			int ring_buffer_first_scanline = (int) (stbir_info.ring_buffer_first_scanline);
			int ring_buffer_last_scanline = (int) (stbir_info.ring_buffer_last_scanline);
			int ring_buffer_length = (int) (stbir_info.ring_buffer_length_bytes/sizeof (ulong));
			int n0;
			int n1;
			n0 = (int) (vertical_contributors[contributor].n0);
			n1 = (int) (vertical_contributors[contributor].n1);
			for (k = (int) (n0); k <= n1; k++)
			{
				{
					int coefficient_index = (int) (k - n0);
					int coefficient_group = (int) (coefficient_width*contributor);
					float coefficient = (float) (vertical_coefficients[coefficient_group + coefficient_index]);
					float* ring_buffer_entry = stbir__get_ring_buffer_scanline((int) (k), ring_buffer, (int) (ring_buffer_begin_index),
						(int) (ring_buffer_first_scanline), (int) (ring_buffer_entries), (int) (ring_buffer_length));
					switch (channels)
					{
						case 1:
							for (x = (int) (0); (x) < (output_w); x++)
							{
								{
									int in_pixel_index = (int) (x*1);
									ring_buffer_entry[in_pixel_index + 0] += (float) (horizontal_buffer[in_pixel_index + 0]*coefficient);
								}
							}
							break;
						case 2:
							for (x = (int) (0); (x) < (output_w); x++)
							{
								{
									int in_pixel_index = (int) (x*2);
									ring_buffer_entry[in_pixel_index + 0] += (float) (horizontal_buffer[in_pixel_index + 0]*coefficient);
									ring_buffer_entry[in_pixel_index + 1] += (float) (horizontal_buffer[in_pixel_index + 1]*coefficient);
								}
							}
							break;
						case 3:
							for (x = (int) (0); (x) < (output_w); x++)
							{
								{
									int in_pixel_index = (int) (x*3);
									ring_buffer_entry[in_pixel_index + 0] += (float) (horizontal_buffer[in_pixel_index + 0]*coefficient);
									ring_buffer_entry[in_pixel_index + 1] += (float) (horizontal_buffer[in_pixel_index + 1]*coefficient);
									ring_buffer_entry[in_pixel_index + 2] += (float) (horizontal_buffer[in_pixel_index + 2]*coefficient);
								}
							}
							break;
						case 4:
							for (x = (int) (0); (x) < (output_w); x++)
							{
								{
									int in_pixel_index = (int) (x*4);
									ring_buffer_entry[in_pixel_index + 0] += (float) (horizontal_buffer[in_pixel_index + 0]*coefficient);
									ring_buffer_entry[in_pixel_index + 1] += (float) (horizontal_buffer[in_pixel_index + 1]*coefficient);
									ring_buffer_entry[in_pixel_index + 2] += (float) (horizontal_buffer[in_pixel_index + 2]*coefficient);
									ring_buffer_entry[in_pixel_index + 3] += (float) (horizontal_buffer[in_pixel_index + 3]*coefficient);
								}
							}
							break;
						default:
							for (x = (int) (0); (x) < (output_w); x++)
							{
								{
									int in_pixel_index = (int) (x*channels);
									int c;
									for (c = (int) (0); (c) < (channels); c++)
									{
										ring_buffer_entry[in_pixel_index + c] += (float) (horizontal_buffer[in_pixel_index + c]*coefficient);
									}
								}
							}
							break;
					}
				}
			}
		}

		public static void stbir__buffer_loop_upsample(stbir__info stbir_info)
		{
			int y;
			float scale_ratio = (float) (stbir_info.vertical_scale);
			float out_scanlines_radius =
				(float) (stbir__filter_info_table[stbir_info.vertical_filter].support((float) (1/scale_ratio))*scale_ratio);
			for (y = (int) (0); (y) < (stbir_info.output_h); y++)
			{
				{
					float in_center_of_out = (float) (0);
					int in_first_scanline = (int) (0);
					int in_last_scanline = (int) (0);
					stbir__calculate_sample_range_upsample((int) (y), (float) (out_scanlines_radius), (float) (scale_ratio),
						(float) (stbir_info.vertical_shift), &in_first_scanline, &in_last_scanline, &in_center_of_out);
					;
					if ((stbir_info.ring_buffer_begin_index) >= (0))
					{
						while ((in_first_scanline) > (stbir_info.ring_buffer_first_scanline))
						{
							{
								if ((stbir_info.ring_buffer_first_scanline) == (stbir_info.ring_buffer_last_scanline))
								{
									stbir_info.ring_buffer_begin_index = (int) (-1);
									stbir_info.ring_buffer_first_scanline = (int) (0);
									stbir_info.ring_buffer_last_scanline = (int) (0);
									break;
								}
								else
								{
									stbir_info.ring_buffer_first_scanline++;
									stbir_info.ring_buffer_begin_index =
										(int) ((stbir_info.ring_buffer_begin_index + 1)%stbir_info.ring_buffer_num_entries);
								}
							}
						}
					}
					if ((stbir_info.ring_buffer_begin_index) < (0))
						stbir__decode_and_resample_upsample(stbir_info, (int) (in_first_scanline));
					while ((in_last_scanline) > (stbir_info.ring_buffer_last_scanline))
					{
						stbir__decode_and_resample_upsample(stbir_info, (int) (stbir_info.ring_buffer_last_scanline + 1));
					}
					stbir__resample_vertical_upsample(stbir_info, (int) (y), (int) (in_first_scanline), (int) (in_last_scanline),
						(float) (in_center_of_out));
					;
				}
			}
		}

		public static void stbir__empty_ring_buffer(stbir__info stbir_info, int first_necessary_scanline)
		{
			int output_stride_bytes = (int) (stbir_info.output_stride_bytes);
			int channels = (int) (stbir_info.channels);
			int alpha_channel = (int) (stbir_info.alpha_channel);
			int type = (int) (stbir_info.type);
			int colorspace = (int) (stbir_info.colorspace);
			int output_w = (int) (stbir_info.output_w);
			void* output_data = stbir_info.output_data;
			int decode = (int) ((type)*(STBIR_MAX_COLORSPACES) + (colorspace));
			float* ring_buffer = stbir_info.ring_buffer;
			int ring_buffer_length = (int) (stbir_info.ring_buffer_length_bytes/sizeof (ulong));
			if ((stbir_info.ring_buffer_begin_index) >= (0))
			{
				while ((first_necessary_scanline) > (stbir_info.ring_buffer_first_scanline))
				{
					{
						if (((stbir_info.ring_buffer_first_scanline) >= (0)) &&
						    ((stbir_info.ring_buffer_first_scanline) < (stbir_info.output_h)))
						{
							int output_row_start = (int) (stbir_info.ring_buffer_first_scanline*output_stride_bytes);
							float* ring_buffer_entry = stbir__get_ring_buffer_entry(ring_buffer, (int) (stbir_info.ring_buffer_begin_index),
								(int) (ring_buffer_length));
							stbir__encode_scanline(stbir_info, (int) (output_w), (sbyte*) (output_data) + output_row_start, ring_buffer_entry,
								(int) (channels), (int) (alpha_channel), (int) (decode));
							;
						}
						if ((stbir_info.ring_buffer_first_scanline) == (stbir_info.ring_buffer_last_scanline))
						{
							stbir_info.ring_buffer_begin_index = (int) (-1);
							stbir_info.ring_buffer_first_scanline = (int) (0);
							stbir_info.ring_buffer_last_scanline = (int) (0);
							break;
						}
						else
						{
							stbir_info.ring_buffer_first_scanline++;
							stbir_info.ring_buffer_begin_index =
								(int) ((stbir_info.ring_buffer_begin_index + 1)%stbir_info.ring_buffer_num_entries);
						}
					}
				}
			}

		}

		public static void stbir__buffer_loop_downsample(stbir__info stbir_info)
		{
			int y;
			float scale_ratio = (float) (stbir_info.vertical_scale);
			int output_h = (int) (stbir_info.output_h);
			float in_pixels_radius =
				(float) (stbir__filter_info_table[stbir_info.vertical_filter].support((float) (scale_ratio))/scale_ratio);
			int pixel_margin = (int) (stbir_info.vertical_filter_pixel_margin);
			int max_y = (int) (stbir_info.input_h + pixel_margin);
			for (y = (int) (-pixel_margin); (y) < (max_y); y++)
			{
				{
					float out_center_of_in;
					int out_first_scanline;
					int out_last_scanline;
					stbir__calculate_sample_range_downsample((int) (y), (float) (in_pixels_radius), (float) (scale_ratio),
						(float) (stbir_info.vertical_shift), &out_first_scanline, &out_last_scanline, &out_center_of_in);
					;
					if (((out_last_scanline) < (0)) || ((out_first_scanline) >= (output_h))) ;
					stbir__empty_ring_buffer(stbir_info, (int) (out_first_scanline));
					stbir__decode_and_resample_downsample(stbir_info, (int) (y));
					if ((stbir_info.ring_buffer_begin_index) < (0))
						stbir__add_empty_ring_buffer_entry(stbir_info, (int) (out_first_scanline));
					while ((out_last_scanline) > (stbir_info.ring_buffer_last_scanline))
					{
						stbir__add_empty_ring_buffer_entry(stbir_info, (int) (stbir_info.ring_buffer_last_scanline + 1));
					}
					stbir__resample_vertical_downsample(stbir_info, (int) (y), (int) (out_first_scanline), (int) (out_last_scanline),
						(float) (out_center_of_in));
				}
			}
			stbir__empty_ring_buffer(stbir_info, (int) (stbir_info.output_h));
		}

		public static void stbir__setup(stbir__info info, int input_w, int input_h, int output_w, int output_h, int channels)
		{
			info.input_w = (int) (input_w);
			info.input_h = (int) (input_h);
			info.output_w = (int) (output_w);
			info.output_h = (int) (output_h);
			info.channels = (int) (channels);
		}

		public static void stbir__calculate_transform(stbir__info info, float s0, float t0, float s1, float t1,
			float* transform)
		{
			info.s0 = (float) (s0);
			info.t0 = (float) (t0);
			info.s1 = (float) (s1);
			info.t1 = (float) (t1);
			if ((transform) != null)
			{
				info.horizontal_scale = (float) (transform[0]);
				info.vertical_scale = (float) (transform[1]);
				info.horizontal_shift = (float) (transform[2]);
				info.vertical_shift = (float) (transform[3]);
			}
			else
			{
				info.horizontal_scale = (float) (((float) (info.output_w)/info.input_w)/(s1 - s0));
				info.vertical_scale = (float) (((float) (info.output_h)/info.input_h)/(t1 - t0));
				info.horizontal_shift = (float) (s0*info.output_w/(s1 - s0));
				info.vertical_shift = (float) (t0*info.output_h/(t1 - t0));
			}

		}

		public static void stbir__choose_filter(stbir__info info, int h_filter, int v_filter)
		{
			if ((h_filter) == (0))
				h_filter =
					(int)
						((stbir__use_upsampling((float) (info.horizontal_scale))) != 0 ? STBIR_FILTER_CATMULLROM : STBIR_FILTER_MITCHELL);
			if ((v_filter) == (0))
				v_filter =
					(int)
						((stbir__use_upsampling((float) (info.vertical_scale))) != 0 ? STBIR_FILTER_CATMULLROM : STBIR_FILTER_MITCHELL);
			info.horizontal_filter = (int) (h_filter);
			info.vertical_filter = (int) (v_filter);
		}

		public static uint stbir__calculate_memory(stbir__info info)
		{
			int pixel_margin =
				(int) (stbir__get_filter_pixel_margin((int) (info.horizontal_filter), (float) (info.horizontal_scale)));
			int filter_height =
				(int) (stbir__get_filter_pixel_width((int) (info.vertical_filter), (float) (info.vertical_scale)));
			info.horizontal_num_contributors =
				(int)
					(stbir__get_contributors((float) (info.horizontal_scale), (int) (info.horizontal_filter), (int) (info.input_w),
						(int) (info.output_w)));
			info.vertical_num_contributors =
				(int)
					(stbir__get_contributors((float) (info.vertical_scale), (int) (info.vertical_filter), (int) (info.input_h),
						(int) (info.output_h)));
			info.ring_buffer_num_entries = (int) (filter_height + 1);
			info.horizontal_contributors_size = (int) (info.horizontal_num_contributors*sizeof (ulong));
			info.horizontal_coefficients_size = (int) (stbir__get_total_horizontal_coefficients(info)*sizeof (ulong));
			info.vertical_contributors_size = (int) (info.vertical_num_contributors*sizeof (ulong));
			info.vertical_coefficients_size = (int) (stbir__get_total_vertical_coefficients(info)*sizeof (ulong));
			info.decode_buffer_size = (int) ((info.input_w + pixel_margin*2)*info.channels*sizeof (ulong));
			info.horizontal_buffer_size = (int) (info.output_w*info.channels*sizeof (ulong));
			info.ring_buffer_size = (int) (info.output_w*info.channels*info.ring_buffer_num_entries*sizeof (ulong));
			info.encode_buffer_size = (int) (info.output_w*info.channels*sizeof (ulong));
			if ((stbir__use_height_upsampling(info)) != 0) info.horizontal_buffer_size = (int) (0);
			else info.encode_buffer_size = (int) (0);
			return
				(uint)
					(info.horizontal_contributors_size + info.horizontal_coefficients_size + info.vertical_contributors_size +
					 info.vertical_coefficients_size + info.decode_buffer_size + info.horizontal_buffer_size + info.ring_buffer_size +
					 info.encode_buffer_size);
		}

		public static int stbir__resize_allocated(stbir__info info, void* input_data, int input_stride_in_bytes,
			void* output_data, int output_stride_in_bytes, int alpha_channel, uint flags, int type, int edge_horizontal,
			int edge_vertical, int colorspace, void* tempmem, ulong tempmem_size_in_bytes)
		{
			ulong memory_required = (ulong) (stbir__calculate_memory(info));
			int width_stride_input =
				(int)
					((input_stride_in_bytes) != 0
						? input_stride_in_bytes
						: info.channels*info.input_w*((byte*) (stbir__type_size))[type]);
			int width_stride_output =
				(int)
					((output_stride_in_bytes) != 0
						? output_stride_in_bytes
						: info.channels*info.output_w*((byte*) (stbir__type_size))[type]);
			if (((info.channels) < (0)) || ((info.channels) > (64))) return (int) (0);
			if ((info.horizontal_filter) >= (6)) return (int) (0);
			if ((info.vertical_filter) >= (6)) return (int) (0);
			if ((alpha_channel) < (0)) flags |= (uint) ((1 << 1) | (1 << 0));
			if (((flags & (1 << 1)) == 0) || ((flags & (1 << 0)) == 0)) ;
			if ((alpha_channel) >= (info.channels)) return (int) (0);
			if (tempmem == null) return (int) (0);
			if ((tempmem_size_in_bytes) < (memory_required)) return (int) (0);
			memset(tempmem, (int) (0), (ulong) (tempmem_size_in_bytes));
			info.input_data = input_data;
			info.input_stride_bytes = (int) (width_stride_input);
			info.output_data = output_data;
			info.output_stride_bytes = (int) (width_stride_output);
			info.alpha_channel = (int) (alpha_channel);
			info.flags = (uint) (flags);
			info.type = (int) (type);
			info.edge_horizontal = (int) (edge_horizontal);
			info.edge_vertical = (int) (edge_vertical);
			info.colorspace = (int) (colorspace);
			info.horizontal_coefficient_width =
				(int) (stbir__get_coefficient_width((int) (info.horizontal_filter), (float) (info.horizontal_scale)));
			info.vertical_coefficient_width =
				(int) (stbir__get_coefficient_width((int) (info.vertical_filter), (float) (info.vertical_scale)));
			info.horizontal_filter_pixel_width =
				(int) (stbir__get_filter_pixel_width((int) (info.horizontal_filter), (float) (info.horizontal_scale)));
			info.vertical_filter_pixel_width =
				(int) (stbir__get_filter_pixel_width((int) (info.vertical_filter), (float) (info.vertical_scale)));
			info.horizontal_filter_pixel_margin =
				(int) (stbir__get_filter_pixel_margin((int) (info.horizontal_filter), (float) (info.horizontal_scale)));
			info.vertical_filter_pixel_margin =
				(int) (stbir__get_filter_pixel_margin((int) (info.vertical_filter), (float) (info.vertical_scale)));
			info.ring_buffer_length_bytes = (int) (info.output_w*info.channels*sizeof (ulong));
			info.decode_buffer_pixels = (int) (info.input_w + info.horizontal_filter_pixel_margin*2);
			info.horizontal_contributors = (stbir__contributors*) (tempmem);
			info.horizontal_coefficients =
				(float*) (((byte*) (info.horizontal_contributors)) + info.horizontal_contributors_size);
			info.vertical_contributors =
				(stbir__contributors*) (((byte*) (info.horizontal_coefficients)) + info.horizontal_coefficients_size);
			info.vertical_coefficients = (float*) (((byte*) (info.vertical_contributors)) + info.vertical_contributors_size);
			info.decode_buffer = (float*) (((byte*) (info.vertical_coefficients)) + info.vertical_coefficients_size);
			if ((stbir__use_height_upsampling(info)) != 0)
			{
				info.horizontal_buffer = ((float*) (0));
				info.ring_buffer = (float*) (((byte*) (info.decode_buffer)) + info.decode_buffer_size);
				info.encode_buffer = (float*) (((byte*) (info.ring_buffer)) + info.ring_buffer_size);
				;
			}
			else
			{
				info.horizontal_buffer = (float*) (((byte*) (info.decode_buffer)) + info.decode_buffer_size);
				info.ring_buffer = (float*) (((byte*) (info.horizontal_buffer)) + info.horizontal_buffer_size);
				info.encode_buffer = ((float*) (0));
				;
			}

			info.ring_buffer_begin_index = (int) (-1);
			stbir__calculate_filters(info, info.horizontal_contributors, info.horizontal_coefficients,
				(int) (info.horizontal_filter), (float) (info.horizontal_scale), (float) (info.horizontal_shift),
				(int) (info.input_w), (int) (info.output_w));
			stbir__calculate_filters(info, info.vertical_contributors, info.vertical_coefficients, (int) (info.vertical_filter),
				(float) (info.vertical_scale), (float) (info.vertical_shift), (int) (info.input_h), (int) (info.output_h));
			if ((stbir__use_height_upsampling(info)) != 0) stbir__buffer_loop_upsample(info);
			else stbir__buffer_loop_downsample(info);
			return (int) (1);
		}

		public static int stbir__resize_arbitrary(void* alloc_context, void* input_data, int input_w, int input_h,
			int input_stride_in_bytes, void* output_data, int output_w, int output_h, int output_stride_in_bytes, float s0,
			float t0, float s1, float t1, float* transform, int channels, int alpha_channel, uint flags, int type, int h_filter,
			int v_filter, int edge_horizontal, int edge_vertical, int colorspace)
		{
			stbir__info info = new stbir__info();
			int result;
			ulong memory_required;
			void* extra_memory;
			stbir__setup(info, (int) (input_w), (int) (input_h), (int) (output_w), (int) (output_h), (int) (channels));
			stbir__calculate_transform(info, (float) (s0), (float) (t0), (float) (s1), (float) (t1), transform);
			stbir__choose_filter(info, (int) (h_filter), (int) (v_filter));
			memory_required = (ulong) (stbir__calculate_memory(info));
			extra_memory = malloc((ulong) (memory_required));
			if (extra_memory == null) return (int) (0);
			result =
				(int)
					(stbir__resize_allocated(info, input_data, (int) (input_stride_in_bytes), output_data,
						(int) (output_stride_in_bytes), (int) (alpha_channel), (uint) (flags), (int) (type), (int) (edge_horizontal),
						(int) (edge_vertical), (int) (colorspace), extra_memory, (ulong) (memory_required)));
			free(extra_memory);
			return (int) (result);
		}

		public static int stbir_resize_uint8(byte* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			byte* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int num_channels)
		{
			return
				(int)
					(stbir__resize_arbitrary(((void*) (0)), input_pixels, (int) (input_w), (int) (input_h),
						(int) (input_stride_in_bytes), output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes),
						(float) (0), (float) (0), (float) (1), (float) (1), ((float*) (0)), (int) (num_channels), (int) (-1), (uint) (0),
						(int) (STBIR_TYPE_UINT8), (int) (STBIR_FILTER_DEFAULT), (int) (STBIR_FILTER_DEFAULT), (int) (STBIR_EDGE_CLAMP),
						(int) (STBIR_EDGE_CLAMP), (int) (STBIR_COLORSPACE_LINEAR)));
		}

		public static int stbir_resize_float(float* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			float* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int num_channels)
		{
			return
				(int)
					(stbir__resize_arbitrary(((void*) (0)), input_pixels, (int) (input_w), (int) (input_h),
						(int) (input_stride_in_bytes), output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes),
						(float) (0), (float) (0), (float) (1), (float) (1), ((float*) (0)), (int) (num_channels), (int) (-1), (uint) (0),
						(int) (STBIR_TYPE_FLOAT), (int) (STBIR_FILTER_DEFAULT), (int) (STBIR_FILTER_DEFAULT), (int) (STBIR_EDGE_CLAMP),
						(int) (STBIR_EDGE_CLAMP), (int) (STBIR_COLORSPACE_LINEAR)));
		}

		public static int stbir_resize_uint8_srgb(byte* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			byte* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int num_channels, int alpha_channel,
			int flags)
		{
			return
				(int)
					(stbir__resize_arbitrary(((void*) (0)), input_pixels, (int) (input_w), (int) (input_h),
						(int) (input_stride_in_bytes), output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes),
						(float) (0), (float) (0), (float) (1), (float) (1), ((float*) (0)), (int) (num_channels), (int) (alpha_channel),
						(uint) (flags), (int) (STBIR_TYPE_UINT8), (int) (STBIR_FILTER_DEFAULT), (int) (STBIR_FILTER_DEFAULT),
						(int) (STBIR_EDGE_CLAMP), (int) (STBIR_EDGE_CLAMP), (int) (STBIR_COLORSPACE_SRGB)));
		}

		public static int stbir_resize_uint8_srgb_edgemode(byte* input_pixels, int input_w, int input_h,
			int input_stride_in_bytes, byte* output_pixels, int output_w, int output_h, int output_stride_in_bytes,
			int num_channels, int alpha_channel, int flags, int edge_wrap_mode)
		{
			return
				(int)
					(stbir__resize_arbitrary(((void*) (0)), input_pixels, (int) (input_w), (int) (input_h),
						(int) (input_stride_in_bytes), output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes),
						(float) (0), (float) (0), (float) (1), (float) (1), ((float*) (0)), (int) (num_channels), (int) (alpha_channel),
						(uint) (flags), (int) (STBIR_TYPE_UINT8), (int) (STBIR_FILTER_DEFAULT), (int) (STBIR_FILTER_DEFAULT),
						(int) (edge_wrap_mode), (int) (edge_wrap_mode), (int) (STBIR_COLORSPACE_SRGB)));
		}

		public static int stbir_resize_uint8_generic(byte* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			byte* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int num_channels, int alpha_channel,
			int flags, int edge_wrap_mode, int filter, int space, void* alloc_context)
		{
			return
				(int)
					(stbir__resize_arbitrary(alloc_context, input_pixels, (int) (input_w), (int) (input_h),
						(int) (input_stride_in_bytes), output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes),
						(float) (0), (float) (0), (float) (1), (float) (1), ((float*) (0)), (int) (num_channels), (int) (alpha_channel),
						(uint) (flags), (int) (STBIR_TYPE_UINT8), (int) (filter), (int) (filter), (int) (edge_wrap_mode),
						(int) (edge_wrap_mode), (int) (space)));
		}

		public static int stbir_resize_uint16_generic(ushort* input_pixels, int input_w, int input_h,
			int input_stride_in_bytes, ushort* output_pixels, int output_w, int output_h, int output_stride_in_bytes,
			int num_channels, int alpha_channel, int flags, int edge_wrap_mode, int filter, int space, void* alloc_context)
		{
			return
				(int)
					(stbir__resize_arbitrary(alloc_context, input_pixels, (int) (input_w), (int) (input_h),
						(int) (input_stride_in_bytes), output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes),
						(float) (0), (float) (0), (float) (1), (float) (1), ((float*) (0)), (int) (num_channels), (int) (alpha_channel),
						(uint) (flags), (int) (STBIR_TYPE_UINT16), (int) (filter), (int) (filter), (int) (edge_wrap_mode),
						(int) (edge_wrap_mode), (int) (space)));
		}

		public static int stbir_resize_float_generic(float* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			float* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int num_channels, int alpha_channel,
			int flags, int edge_wrap_mode, int filter, int space, void* alloc_context)
		{
			return
				(int)
					(stbir__resize_arbitrary(alloc_context, input_pixels, (int) (input_w), (int) (input_h),
						(int) (input_stride_in_bytes), output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes),
						(float) (0), (float) (0), (float) (1), (float) (1), ((float*) (0)), (int) (num_channels), (int) (alpha_channel),
						(uint) (flags), (int) (STBIR_TYPE_FLOAT), (int) (filter), (int) (filter), (int) (edge_wrap_mode),
						(int) (edge_wrap_mode), (int) (space)));
		}

		public static int stbir_resize(void* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			void* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int datatype, int num_channels,
			int alpha_channel, int flags, int edge_mode_horizontal, int edge_mode_vertical, int filter_horizontal,
			int filter_vertical, int space, void* alloc_context)
		{
			return
				(int)
					(stbir__resize_arbitrary(alloc_context, input_pixels, (int) (input_w), (int) (input_h),
						(int) (input_stride_in_bytes), output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes),
						(float) (0), (float) (0), (float) (1), (float) (1), ((float*) (0)), (int) (num_channels), (int) (alpha_channel),
						(uint) (flags), (int) (datatype), (int) (filter_horizontal), (int) (filter_vertical), (int) (edge_mode_horizontal),
						(int) (edge_mode_vertical), (int) (space)));
		}

		public static int stbir_resize_subpixel(void* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			void* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int datatype, int num_channels,
			int alpha_channel, int flags, int edge_mode_horizontal, int edge_mode_vertical, int filter_horizontal,
			int filter_vertical, int space, void* alloc_context, float x_scale, float y_scale, float x_offset, float y_offset)
		{
			float* transform = stackalloc float[4];
			((float*) (transform))[0] = (float) (x_scale);
			((float*) (transform))[1] = (float) (y_scale);
			((float*) (transform))[2] = (float) (x_offset);
			((float*) (transform))[3] = (float) (y_offset);
			return
				(int)
					(stbir__resize_arbitrary(alloc_context, input_pixels, (int) (input_w), (int) (input_h),
						(int) (input_stride_in_bytes), output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes),
						(float) (0), (float) (0), (float) (1), (float) (1), ((float*) (transform)), (int) (num_channels),
						(int) (alpha_channel), (uint) (flags), (int) (datatype), (int) (filter_horizontal), (int) (filter_vertical),
						(int) (edge_mode_horizontal), (int) (edge_mode_vertical), (int) (space)));
		}

		public static int stbir_resize_region(void* input_pixels, int input_w, int input_h, int input_stride_in_bytes,
			void* output_pixels, int output_w, int output_h, int output_stride_in_bytes, int datatype, int num_channels,
			int alpha_channel, int flags, int edge_mode_horizontal, int edge_mode_vertical, int filter_horizontal,
			int filter_vertical, int space, void* alloc_context, float s0, float t0, float s1, float t1)
		{
			return
				(int)
					(stbir__resize_arbitrary(alloc_context, input_pixels, (int) (input_w), (int) (input_h),
						(int) (input_stride_in_bytes), output_pixels, (int) (output_w), (int) (output_h), (int) (output_stride_in_bytes),
						(float) (s0), (float) (t0), (float) (s1), (float) (t1), ((float*) (0)), (int) (num_channels),
						(int) (alpha_channel), (uint) (flags), (int) (datatype), (int) (filter_horizontal), (int) (filter_vertical),
						(int) (edge_mode_horizontal), (int) (edge_mode_vertical), (int) (space)));
		}

	}
}